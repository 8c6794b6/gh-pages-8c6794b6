<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Warm Fuzzy Thing - Another instance deriving example with template haskell</title>
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/ico">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/hk-tango.css">
    <link rel="alternate" type="application/rss+xml" title="Warm Fuzzy Thing" href="../rss.xml">
  </head>
  <body>
    <div>
      <div id="site_name">
        <div id="site_name_contents">
          <a href="../index.html">Warm Fuzzy Thing</a>
        </div>
      </div>

      <div id="header">
        <div id="header_contents">
          <div id="navigation">
            <a href="../index.html">Home</a>
            <a href="../archive.html">Archive</a>
            <a href="../rss.xml">RSS</a>
          </div>
        </div>
      </div>

      <div id="content">

        <h1>Another instance deriving example with template haskell</h1>
<div id="post_date">
  <strong>Octover 22, 2011</strong>
</div>

<div id="post_body">
<p>When I was writing small template haskell helper for deriving numeric classes, couldn’t find an example for deriving instance with passing functions. Deriving a type class with helper functions means, for instance, we write below code in client module:</p>
<pre><code>| deriveNum ''S 'i2s 'unaryS 'binaryS
</code></pre>
<p>to get this result:</p>
<pre><code>| instance Num S where
|   (+) = binaryS &quot;+&quot;
|   (*) = binaryS &quot;*&quot;
|   (-) = binaryS &quot;-&quot;
|   negate = unaryS &quot;negate&quot;
|   abs = unaryS &quot;abs&quot;
|   signum = unaryS &quot;signum&quot;
|   fromInteger = i2s
</code></pre>
<p>where <code>i2s</code>, <code>unaryS</code>, and <code>binaryS</code> are defined in client side code.</p>
<p>Template haskell helper for deriving instance seems quite common, used in couple packages like <a href="http://hackage.haskell.org/package/safecopy">safecopy</a>.</p>
<p>There is a <a href="http://www.haskell.org/haskellwiki/Template_haskell/Instance_deriving_example">haskell wiki page showing template haskell example for deriving instance</a>, however, this was not the case I was looking. Using <a href="http://community.haskell.org/~ndm/darcs/derive/derive.htm">Data.Derive</a> might help, but in this case, seemed a bit different.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">{-# LANGUAGE TemplateHaskell #-}</span><br />&gt; <span class="ot">{-# LANGUAGE OverloadedStrings #-}</span><br />&gt; <br />&gt; <span class="kw">module</span> <span class="dt">THDeriveExample</span> <span class="kw">where</span><br />&gt; <br />&gt; <span class="kw">import</span> <span class="dt">Control.Monad</span><br />&gt; <span class="kw">import</span> <span class="dt">Data.String</span><br />&gt; <span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></code></pre>
<p>In client side module, suppose that we’re writing a string representation for numeric expressions:</p>
<pre><code>| newtype S = S {unS :: String}
|
| instance Show S where
|   show = unS
|
| instance Eq S where
|   a == b = unS a == unS b
|
| sint :: Int -&gt; S
| sint x = S $ show x
|
| sabs :: S -&gt; S
| sabs a = S $ concat [&quot;(abs&quot;, unS a, &quot;)&quot;]
|
| sadd :: S -&gt; S -&gt; S
| sadd a b = S $ concat [&quot;(&quot;, unS a, &quot; + &quot;, unS b, &quot;)&quot;]
</code></pre>
<p>… and so on. It seems useful if we can use operators ‘(+)’, ‘(*)’, ‘(-)’ directly. Instead of defining smul, snegate .. etc, using helper functions to do this.</p>
<pre><code>| unaryS :: String -&gt; S -&gt; S
| unaryS op a = S $ concat [&quot;(&quot;, op, unS a, &quot;)&quot;]
|
| binaryS :: String -&gt; S -&gt; S -&gt; S
| binaryS op a b = S $ concat [&quot;(&quot;, unS a, &quot; &quot;, op, &quot; &quot;, unS b, &quot;)&quot;]
|
| i2s :: Integer -&gt; S
| i2s a = S $ show (fromInteger a)
</code></pre>
<p>As shown above, calling the template haskell helper</p>
<pre><code>| deriveNum ''S 'i2s 'unaryS 'binaryS
</code></pre>
<p>gives output something similar to this:</p>
<pre><code>| instance Num S where
|   (+) = binaryS &quot;+&quot;
|   (*) = binaryS &quot;*&quot;
|   (-) = binaryS &quot;-&quot;
|   negate = unaryS &quot;negate&quot;
|   abs = unaryS &quot;abs&quot;
|   signum = unaryS &quot;signum&quot;
|   fromInteger = i2s
</code></pre>
<p>So that we can write expressions and view the result:</p>
<pre><code>| *Main&gt; unS ((3 + 10) * 8)
| &quot;((3 + 10) * 8)&quot;
</code></pre>
<p>We can write deriving definitions manually, but when the newtype increase, the template haskell instance deriver helps us a lot. Suppose we want a expression node tree instead of raw string representation.</p>
<pre><code>| data Tree = Empty | Node String [Tree]
| data T = T {unT :: Tree}
</code></pre>
<p>and in addition to Num, we might want to derive Floating. I don’t want to do this manually anymore.</p>
<pre><code>| class Fractional a =&gt; Floating a where
|   pi :: a
|   exp :: a -&gt; a
|   sqrt :: a -&gt; a
|   log :: a -&gt; a
|   (**) :: a -&gt; a -&gt; a
|   logBase :: a -&gt; a -&gt; a
|   sin :: a -&gt; a
|   tan :: a -&gt; a
|   cos :: a -&gt; a
|   asin :: a -&gt; a
|   atan :: a -&gt; a
|   acos :: a -&gt; a
|   sinh :: a -&gt; a
|   tanh :: a -&gt; a
|   cosh :: a -&gt; a
|   asinh :: a -&gt; a
|   atanh :: a -&gt; a
|   acosh :: a -&gt; a
</code></pre>
<p>As written above, usage of the template haskell function we want to write is:</p>
<pre><code>| deriveNum ''Constuctor 'lifter 'unary 'binary
</code></pre>
<p>and it should generate:</p>
<pre><code>| instance Num ''Constructor where
|   (+) = 'binary &quot;+&quot;
|   (*) = 'binary &quot;*&quot;
|   (-) = 'binary &quot;-&quot;
|   negate = 'unary &quot;negate&quot;
|   abs = 'unary &quot;abs&quot;
|   signum = 'unary &quot;signum&quot;
|   fromInteger = 'liter
</code></pre>
<p>Firstly, a function to view TH expression in pretty format.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">ppQ </span><span class="ot">::</span> <span class="dt">Ppr</span> a <span class="ot">=&gt;</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()<br />&gt; ppQ x <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="fu">=&lt;&lt;</span> runQ ((<span class="fu">show</span> <span class="fu">.</span> ppr) <span class="ot">`fmap`</span> x)</code></pre>
<p>and a dumper:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">showQ </span><span class="ot">::</span> <span class="kw">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()<br />&gt; showQ x <span class="fu">=</span> <span class="fu">putStrLn</span> <span class="fu">=&lt;&lt;</span> runQ (<span class="fu">show</span> <span class="ot">`fmap`</span> x)</code></pre>
<p>Using <code>instanceD</code> from <a href="http://hackage.haskell.org/packages/archive/template-haskell/latest/doc/html/Language-Haskell-TH.html#v:instanceD">Language.Haskell.TH</a> to define instance deriving.</p>
<pre><code>| instanceD :: CxtQ -&gt; TypeQ -&gt; [DecQ] -&gt; DecQ
</code></pre>
<p>Below is the body of main deriving helper. We will fill in the arguments passed to <code>instanceD'</code>, each by each.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">deriveNum </span><span class="ot">::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]<br />&gt; deriveNum constr lifter unary binary <span class="fu">=</span> <span class="kw">do</span><br />&gt;   <span class="kw">let</span> instanceD' c t ds <span class="fu">=</span> <span class="fu">fmap</span> (<span class="fu">:</span>[]) (instanceD c t ds)<br />&gt;       contexts <span class="fu">=</span> cxt []<br />&gt;       typ <span class="fu">=</span> mkNumTyp constr<br />&gt;   decs <span class="ot">&lt;-</span> mkNumDecs lifter unary binary<br />&gt;   instanceD' contexts typ decs</code></pre>
<p>The desired result type is <code>Q [Dec]</code>, not <code>Q Dec</code>. So wrapping as single element list with <code>fmap</code> and <code>(:[])</code>. There is no constraints used in result output, list passed to <code>cxt</code> is empty.</p>
<p>We want a function:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">mkNumTyp </span><span class="ot">::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">TypeQ</span></code></pre>
<p>so that it will represent <code>Num S</code> part of below expression:</p>
<pre><code>| instance Num S where
</code></pre>
<p>Using expression quotatin with <code>t</code> prefix, to get <code>TypeQ</code> result type.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; mkNumTyp con <span class="fu">=</span> [t<span class="fu">|</span> <span class="fu">$</span>(conT <span class="ch">''</span><span class="dt">Num</span>) <span class="fu">$</span>(conT con) <span class="fu">|</span>]</code></pre>
<p>Viewing the result:</p>
<pre><code>| *THDeriveExample&gt; ppQ $ mkNumTyp ''Int
| GHC.Num.Num GHC.Types.Int
</code></pre>
<p>It is verbose, but that is what we want.</p>
<pre><code>| *THDeriveExample&gt; showQ $ mkNumTyp ''Int
| AppT (ConT GHC.Num.Num) (ConT GHC.Types.Int)
</code></pre>
<p>Body of definitions:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">mkNumDecs </span><span class="ot">::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">DecQ</span>]<br />&gt; mkNumDecs lifter unary binary <span class="fu">=</span><br />&gt;   <span class="kw">let</span> lifter' <span class="fu">=</span> varE lifter<br />&gt;       unary'  <span class="fu">=</span> varE unary<br />&gt;       binary' <span class="fu">=</span> varE binary<br />&gt;   <span class="kw">in</span> <span class="fu">fmap</span> (<span class="fu">fmap</span> <span class="fu">return</span>)<br />&gt;      [d<span class="fu">|</span> (<span class="fu">+</span>) <span class="fu">=</span> <span class="fu">$</span>binary' <span class="st">&quot;+&quot;</span><br />&gt;          (<span class="fu">*</span>) <span class="fu">=</span> <span class="fu">$</span>binary' <span class="st">&quot;*&quot;</span><br />&gt;          (<span class="fu">-</span>) <span class="fu">=</span> <span class="fu">$</span>binary' <span class="st">&quot;-&quot;</span><br />&gt;          <span class="fu">abs</span> <span class="fu">=</span> <span class="fu">$</span>unary' <span class="st">&quot;abs&quot;</span><br />&gt;          <span class="fu">negate</span> <span class="fu">=</span> <span class="fu">$</span>unary' <span class="st">&quot;negate&quot;</span><br />&gt;          <span class="fu">signum</span> <span class="fu">=</span> <span class="fu">$</span>unary' <span class="st">&quot;signum&quot;</span><br />&gt;          <span class="fu">fromIntegral</span> x <span class="fu">=</span> <span class="fu">$</span>lifter' x <span class="fu">|</span>]</code></pre>
<p>Using declaration expression quotation prefixed with <code>d</code> to get <code>Q [Dec]</code> result type.</p>
<p>Since declaration blocks has type:</p>
<pre><code>| *THDeriveExample&gt; :t [d| |]
| [d||] :: Q [Dec]
</code></pre>
<p>Pushing <code>return</code> function to inner elements of list inside <code>Q</code> monad.</p>
<p>Helper adhoc orphan instance.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="kw">instance</span> <span class="dt">IsString</span> <span class="dt">Name</span> <span class="kw">where</span><br />&gt;   fromString <span class="fu">=</span> mkName</code></pre>
<p>Pretty printing the result of <code>deriveNum</code>. We use S newtype and related functions shown in the beginning.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="kw">newtype</span> <span class="dt">S</span> <span class="fu">=</span> <span class="dt">S</span> {<span class="ot">unS </span><span class="ot">::</span> <span class="dt">String</span>}<br />&gt; <br />&gt; <span class="ot">i2s </span><span class="ot">::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">S</span><br />&gt; i2s <span class="fu">=</span> <span class="dt">S</span> <span class="fu">.</span> <span class="fu">show</span> <span class="fu">.</span> <span class="fu">fromIntegral</span><br />&gt; <br />&gt; <span class="ot">unaryS </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">S</span> <span class="ot">-&gt;</span> <span class="dt">S</span><br />&gt; unaryS op a <span class="fu">=</span> <span class="dt">S</span> <span class="fu">$</span> <span class="fu">concat</span> [<span class="st">&quot;(&quot;</span>, op, unS a, <span class="st">&quot;)&quot;</span>]<br />&gt; <br />&gt; <span class="ot">binaryS </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">S</span> <span class="ot">-&gt;</span> <span class="dt">S</span> <span class="ot">-&gt;</span> <span class="dt">S</span><br />&gt; binaryS op a b <span class="fu">=</span> <span class="dt">S</span> <span class="fu">$</span> <span class="fu">concat</span> [<span class="st">&quot;(&quot;</span>, unS a, <span class="st">&quot; &quot;</span>, op, <span class="st">&quot; &quot;</span>, unS b, <span class="st">&quot;)&quot;</span>]</code></pre>
<p>Pretty printing this in ghci will print:</p>
<pre><code>| *THDeriveExample&gt; :set -XTemplateHaskell
| *THDeriveExample&gt; ppQ $ deriveNum ''S 'i2s 'unaryS 'binaryS
| instance GHC.Num.Num THDeriveExample.S
|     where (+) = THDeriveExample.binaryS &quot;+&quot;
|           (*) = THDeriveExample.binaryS &quot;*&quot;
|           (-) = THDeriveExample.binaryS &quot;-&quot;
|           abs = THDeriveExample.unaryS &quot;abs&quot;
|           negate = THDeriveExample.unaryS &quot;negate&quot;
|           signum = THDeriveExample.unaryS &quot;signum&quot;
|           fromIntegral x_0 = THDeriveExample.i2s x_0
</code></pre>
<p>It is verbose, and using extra index for variable name, though this is what we’ve intended to generate.</p>
</div>

<div class="post_tags">
  <strong>Tags: </strong><a href="../tags/haskell.html">haskell</a>, <a href="../tags/templatehaskell.html">templatehaskell</a>
</div>


      </div>
      <div id="footer">
        <div id="footer_content">
          <p>
            <a href="../index.html">Home</a> |
            <a href="../archive.html">Archive</a> |
            <a href="../rss.xml">RSS</a>
          </p>

          Site contents licensed under
          <a href="http://creativecommons.org/licenses/by/3.0/">
            CC Attribution 3.0
          </a>
        </div>
      </div>
    </div>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Warm Fuzzy Thing - Adhoc update of ugen parameters</title>
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/ico">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/hk-tango.css">
    <link rel="alternate" type="application/rss+xml" title="Warm Fuzzy Thing" href="../rss.xml">
  </head>
  <body>
    <div>
      <div id="site_name">
        <div id="site_name_contents">
          <a href="../index.html">Warm Fuzzy Thing</a>
        </div>
      </div>

      <div id="header">
        <div id="header_contents">
          <div id="navigation">
            <a href="../index.html">Home</a>
            <a href="../archive.html">Archive</a>
            <a href="../rss.xml">RSS</a>
          </div>
        </div>
      </div>

      <div id="content">

        <h1>Adhoc update of ugen parameters</h1>
<div id="post_date">
  <strong>Octover 25, 2011</strong>
</div>

<div id="post_body">
<p>Adhoc update of UGen parameters, with generic functions.</p>
<p>Requires ghc 7.0 or higher:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">{-# LANGUAGE DeriveDataTypeable, StandaloneDeriving #-}</span><br />&gt; <span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span><br />&gt; <br />&gt; <span class="kw">module</span> <span class="dt">AdhocUpdate</span> <span class="kw">where</span><br />&gt; <br />&gt; <span class="kw">import</span> <span class="dt">Control.Monad</span><br />&gt; <span class="kw">import</span> <span class="dt">Data.Data</span> (<span class="dt">Data</span>, <span class="dt">Typeable</span>)<br />&gt; <span class="kw">import</span> <span class="dt">Data.Generics</span> (everywhere, mkT)<br />&gt; <span class="kw">import</span> <span class="dt">Data.List</span> (zipWith4)<br />&gt; <span class="kw">import</span> <span class="dt">Control.Concurrent</span> (forkIO, threadDelay)<br />&gt; <span class="kw">import</span> <span class="dt">System.Random</span><br />&gt; <br />&gt; <span class="kw">import</span> <span class="dt">Sound.SC3</span><br />&gt; <span class="kw">import</span> <span class="dt">Sound.SC3.ID</span><br />&gt; <span class="kw">import</span> <span class="dt">Data.Generics.Uniplate.Data</span> (transform, transformM)</code></pre>
<p>To play sound example, run:</p>
<pre><code>| $ scsynth -u 57110
</code></pre>
<p>before invoking OSC sending actions.</p>
<p>We have a synth named <code>s01</code>, written with unit generator function from hsc3.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">s01 </span><span class="ot">::</span> <span class="dt">UGen</span><br />&gt; s01 <span class="fu">=</span><br />&gt;   <span class="kw">let</span> o <span class="fu">=</span> control <span class="dt">IR</span> <span class="st">&quot;out&quot;</span> <span class="dv">0</span><br />&gt;       p <span class="fu">=</span> control <span class="dt">KR</span> <span class="st">&quot;pan&quot;</span> <span class="dv">0</span><br />&gt;       f <span class="fu">=</span> control <span class="dt">KR</span> <span class="st">&quot;freq&quot;</span> <span class="dv">440</span><br />&gt;       d <span class="fu">=</span> control <span class="dt">KR</span> <span class="st">&quot;decay&quot;</span> <span class="dv">1</span><br />&gt;       e <span class="fu">=</span> linen (impulse <span class="dt">KR</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">1</span> <span class="dv">0</span>) 1e<span class="fu">-</span><span class="dv">2</span> <span class="dv">1</span> d <span class="dt">RemoveSynth</span><br />&gt;       s <span class="fu">=</span> pan2 (sinOsc <span class="dt">AR</span> f <span class="dv">0</span> <span class="fu">*</span> e <span class="fu">*</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">3</span>) p <span class="dv">1</span><br />&gt;   <span class="kw">in</span>  out o s</code></pre>
<p>Actions to make sound with <code>s01</code>:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">prepare </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; prepare <span class="fu">=</span> withSC3 reset<br />&gt; <br />&gt; <span class="ot">play_s01a </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; play_s01a <span class="fu">=</span> audition s01</code></pre>
<p>Play it:</p>
<pre><code>| *AdhocUpdate&gt; parepare &gt;&gt; play_s01a
</code></pre>
<p>It makes 440 Hz sine tone, with 1 second decay time, positioning center. There are 4 control parameters in s01: out, pan, freq, and decay. What we want to do is to use different values for these parameters. It is possible to set different value by:</p>
<ul>
<li>Send above synthdef to scsynth server</li>
<li>Wait till the server load the synthdef</li>
<li>Send <code>s_new</code> message to play the synthdef with new parameters</li>
</ul>
<p>We can send <code>s_new</code> message with only those parameters which we want to update.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; play_s01b <span class="fu">=</span> withSC3 <span class="fu">$</span> \fd <span class="ot">-&gt;</span> <span class="kw">do</span><br />&gt;   async fd (d_recv <span class="fu">$</span> synthdef <span class="st">&quot;s01&quot;</span> s01)<br />&gt;   send fd <span class="fu">$</span> s_new <span class="st">&quot;s01&quot;</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="dt">AddToTail</span> <span class="dv">1</span> [(<span class="st">&quot;freq&quot;</span>,<span class="dv">3300</span>),(<span class="st">&quot;decay&quot;</span>,<span class="dv">0</span><span class="fu">.</span><span class="dv">3</span>)]</code></pre>
<p>Is there any other way to do this? We can pass parameters as function arguments:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; s01' o p f d <span class="fu">=</span><br />&gt;   <span class="kw">let</span> e <span class="fu">=</span> linen (impulse <span class="dt">KR</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">1</span> <span class="dv">0</span>) 1e<span class="fu">-</span><span class="dv">2</span> <span class="dv">1</span> d <span class="dt">RemoveSynth</span><br />&gt;       s <span class="fu">=</span> pan2 (sinOsc <span class="dt">AR</span> f <span class="dv">0</span> <span class="fu">*</span> e <span class="fu">*</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">3</span>) p <span class="dv">1</span><br />&gt;   <span class="kw">in</span>  out o s</code></pre>
<p>But in this manner, we need to specify all values.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; play_s01c <span class="fu">=</span> audition <span class="fu">$</span> s01' <span class="dv">0</span> <span class="dv">0</span> <span class="dv">3300</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">3</span></code></pre>
<p>Can we update specified values only, without sending synthdef, like:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; play_s01d <span class="fu">=</span> audition <span class="fu">$</span> ups <span class="st">&quot;freq&quot;</span> <span class="dv">3300</span> <span class="fu">$</span> ups <span class="st">&quot;decay&quot;</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">3</span> s01</code></pre>
<p>We can do this with functions in generic modules.</p>
<p>UGen data is defined as:</p>
<pre><code>| data UGen
|   = Constant {constantValue :: Double}
|   | Control {controlOperatingRate :: Rate,
|              controlName :: String,
|              controlDefault :: Double,
|              controlTriggered :: Bool}
|   | Primitive {ugenRate :: Rate,
|                ugenName :: String,
|                ugenInputs :: [UGen],
|                ugenOutputs :: [Output],
|                ugenSpecial :: Special,
|                ugenId :: Int}
|   | Proxy {proxySource :: UGen, proxyIndex :: Int}
|   | MCE {mceProxies :: [UGen]}
|   | MRG {mrgLeft :: UGen, mrgRight :: UGen}
</code></pre>
<p>We use <code>Data</code> and <code>Typeable</code> instances for data types used inside <code>UGen</code> graph. In hsc3â€“0.9, <code>UGen</code> is not defined as instance of Data. Using <code>StandaloneDeriving</code> LANGUAGE pragma to avoid writing boiler plate codes.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">UGen</span><br />&gt; <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Typeable</span> <span class="dt">UGen</span><br />&gt; <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Rate</span><br />&gt; <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Typeable</span> <span class="dt">Rate</span><br />&gt; <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Special</span><br />&gt; <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Typeable</span> <span class="dt">Special</span><br />&gt; <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">UGenId</span><br />&gt; <span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Typeable</span> <span class="dt">UGenId</span></code></pre>
<p>We want to update <code>UGen</code> with <code>Control</code> constructor only, and only if specified parameter name has matched. This could be done with using <code>everywhere</code> from syb.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">ups </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span><br />&gt; ups key value ug <span class="fu">=</span> everywhere (mkT f) ug <span class="kw">where</span><br />&gt;   f (<span class="dt">Control</span> r key' _ t) <span class="fu">|</span> key <span class="fu">==</span> key' <span class="fu">=</span> <span class="dt">Control</span> r key value t<br />&gt;   f x                    <span class="fu">=</span> x</code></pre>
<p>Play updated sound:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; play_s01e <span class="fu">=</span> audition <span class="fu">.</span> ups <span class="st">&quot;freq&quot;</span> <span class="dv">3300</span> <span class="fu">.</span> ups <span class="st">&quot;decay&quot;</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">3</span> <span class="fu">$</span> s01</code></pre>
<p>Or, using <code>transform</code> from uniplate package.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">upu </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span><br />&gt; upu key value ug <span class="fu">=</span> transform f ug <span class="kw">where</span><br />&gt;   f (<span class="dt">Control</span> r key' _ t) <span class="fu">|</span> key <span class="fu">==</span> key' <span class="fu">=</span> <span class="dt">Control</span> r key value t<br />&gt;   f x                    <span class="fu">=</span> x</code></pre>
<p>We can use in same manner as ups.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; play_s01e' <span class="fu">=</span> audition <span class="fu">.</span> upu <span class="st">&quot;freq&quot;</span> <span class="dv">3300</span> <span class="fu">.</span> upu <span class="st">&quot;decay&quot;</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">3</span> <span class="fu">$</span> s01</code></pre>
<p>Howâ€™s its performance? Since we need to traverse synth structure and find out whether control name matches or not, it should spend more time than raw messaging style.</p>
<p>Simple grain sound, 1ms decay time sine tone in message sending style:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; play_s01f x <span class="fu">=</span><br />&gt;   withSC3 <span class="fu">.</span> <span class="fu">flip</span> send <span class="fu">.</span> s_new <span class="st">&quot;s01&quot;</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="dt">AddToTail</span> <span class="dv">1</span> <span class="fu">$</span><br />&gt;   [(<span class="st">&quot;freq&quot;</span>,x),(<span class="st">&quot;decay&quot;</span>,<span class="dv">0</span><span class="fu">.</span><span class="dv">001</span>)]</code></pre>
<p>And in generic updating style:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; play_s01g x <span class="fu">=</span> audition <span class="fu">$</span> upu <span class="st">&quot;freq&quot;</span> x <span class="fu">.</span> upu <span class="st">&quot;decay&quot;</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">001</span> <span class="fu">$</span> s01</code></pre>
<p>Grain generator with 500 nano seconds interval.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; mkgrn k <span class="fu">=</span><br />&gt;   <span class="fu">sequence_</span> <span class="fu">$</span> <span class="fu">map</span> (k <span class="fu">&gt;=&gt;</span> <span class="fu">const</span> (threadDelay <span class="dv">500</span>)) [<span class="dv">10000</span>,<span class="dv">9931</span><span class="fu">..</span><span class="dv">0</span>]</code></pre>
<p>Message sending style:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">grn01 </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; grn01 <span class="fu">=</span> mkgrn play_s01f</code></pre>
<p>Generic update style:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">grn02 </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; grn02 <span class="fu">=</span> mkgrn play_s01g</code></pre>
<p>Note that, difference is not only coming from parameter update. In <code>play_s01g</code>, entire new synthdef need to be sent to server, this synthdef sending is not so quick to do in 500 nano seconds.</p>
<p>From performance perspective, message passing style is superior to generic updating style. This is same in SClang, described in <a href="http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/NodeMessaging.html">NodeMessaging SC help file</a>.</p>
<p>Thereâ€™s different use cases for generic update.</p>
<p>One is, sending variation of synthdefs. When we know that only fixed variation of parameters are used for certain synthdef, we can send multiple synthdef with different default values in advance. This approach resembles to <code>variants</code> concepts, shown in <a href="http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/SynthDef.html">SynthDef SC help file</a>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">prepare_s01_variants </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; prepare_s01_variants <span class="fu">=</span> withSC3 <span class="fu">$</span> \fd <span class="ot">-&gt;</span><br />&gt;   <span class="fu">mapM_</span> (\(n,u) <span class="ot">-&gt;</span> async fd <span class="fu">$</span> d_recv <span class="fu">$</span> synthdef n u)<br />&gt;     [ (<span class="st">&quot;s01_alpha&quot;</span>,upu <span class="st">&quot;pan&quot;</span> <span class="dv">1</span> <span class="fu">$</span> upu <span class="st">&quot;freq&quot;</span> <span class="dv">880</span> s01)<br />&gt;     , (<span class="st">&quot;s01_beta&quot;</span>, upu <span class="st">&quot;pan&quot;</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="fu">$</span> upu <span class="st">&quot;freq&quot;</span> <span class="dv">1320</span> s01)<br />&gt;     , (<span class="st">&quot;s01_gamma&quot;</span>,upu <span class="st">&quot;freq&quot;</span> <span class="dv">2640</span> s01) ]</code></pre>
<p>Parameters in <code>play_variants_01</code> are specified in message list, parameters in <code>play_variants_02</code> are predefined in synth definition. When sending lots of <code>s_new</code> messages with fixed value variations, predefined approach will same the amount of data transfered to server, since it contains no parameter values in message body.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">play_variants_01 </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; play_variants_01 <span class="fu">=</span> withSC3 <span class="fu">$</span> \fd <span class="ot">-&gt;</span><br />&gt;   <span class="kw">let</span> ms <span class="fu">=</span> [ [(<span class="st">&quot;freq&quot;</span>,<span class="dv">880</span>),(<span class="st">&quot;pan&quot;</span>,<span class="dv">1</span>)]<br />&gt;            , [(<span class="st">&quot;freq&quot;</span>, <span class="dv">1320</span>),(<span class="st">&quot;pan&quot;</span>,<span class="fu">-</span><span class="dv">1</span>)]<br />&gt;            , [(<span class="st">&quot;freq&quot;</span>,<span class="dv">2640</span>)]<br />&gt;            , [(<span class="st">&quot;freq&quot;</span>, <span class="dv">1320</span>),(<span class="st">&quot;pan&quot;</span>,<span class="fu">-</span><span class="dv">1</span>)]<br />&gt;            , [(<span class="st">&quot;freq&quot;</span>,<span class="dv">2640</span>)]<br />&gt;            , [(<span class="st">&quot;freq&quot;</span>,<span class="dv">880</span>),(<span class="st">&quot;pan&quot;</span>,<span class="dv">1</span>)] ]<br />&gt;   <span class="kw">in</span>  forM_ ms <span class="fu">$</span> \m <span class="ot">-&gt;</span><br />&gt;         send fd (s_new <span class="st">&quot;s01&quot;</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="dt">AddToTail</span> <span class="dv">1</span> m) <span class="fu">&gt;&gt;</span> threadDelay (<span class="dv">5</span><span class="fu">*</span><span class="dv">10</span><span class="fu">^</span><span class="dv">5</span>)<br />&gt; <br />&gt; <span class="ot">play_variants_02 </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; play_variants_02 <span class="fu">=</span> withSC3 <span class="fu">$</span> \fd <span class="ot">-&gt;</span><br />&gt;   <span class="kw">let</span> ds <span class="fu">=</span> [ <span class="st">&quot;s01_alpha&quot;</span>, <span class="st">&quot;s01_beta&quot;</span>, <span class="st">&quot;s01_gamma&quot;</span><br />&gt;            , <span class="st">&quot;s01_beta&quot;</span>, <span class="st">&quot;s01_gamma&quot;</span>, <span class="st">&quot;s01_alpha&quot;</span> ]<br />&gt;   <span class="kw">in</span>  forM_ ds <span class="fu">$</span> \d <span class="ot">-&gt;</span><br />&gt;         send fd (s_new d (<span class="fu">-</span><span class="dv">1</span>) <span class="dt">AddToTail</span> <span class="dv">1</span> []) <span class="fu">&gt;&gt;</span> threadDelay (<span class="dv">5</span><span class="fu">*</span><span class="dv">10</span><span class="fu">^</span><span class="dv">5</span>)</code></pre>
<p>Another usage of generic update approach is, <code>UGen</code> replacing.</p>
<p>There are couple oscillator functions with type â€˜Rate -&gt; UGen -&gt; UGen -&gt; UGenâ€™:</p>
<pre><code>| sinOsc :: Rate -&gt; UGen -&gt; UGen -&gt; UGen
| lfCub :: Rate -&gt; UGen -&gt; UGen -&gt; UGen
| lfPar :: Rate -&gt; UGen -&gt; UGen -&gt; UGen
| lfSaw :: Rate -&gt; UGen -&gt; UGen -&gt; UGen
| lfTri :: Rate -&gt; UGen -&gt; UGen -&gt; UGen
</code></pre>
<p>We can write a function taking these oscillator:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; mks02 o <span class="fu">=</span><br />&gt;  <span class="kw">let</span> s <span class="fu">=</span> pan2 (o <span class="dt">AR</span> f <span class="dv">0</span> <span class="fu">*</span> e <span class="fu">*</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">3</span>) p <span class="dv">1</span><br />&gt;      e <span class="fu">=</span> envGen <span class="dt">KR</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dt">RemoveSynth</span> (envPerc 1e<span class="fu">-</span><span class="dv">2</span> <span class="dv">1</span>)<br />&gt;      f <span class="fu">=</span> control <span class="dt">KR</span> <span class="st">&quot;freq&quot;</span> <span class="dv">440</span><br />&gt;      p <span class="fu">=</span> control <span class="dt">KR</span> <span class="st">&quot;pan&quot;</span> <span class="dv">0</span><br />&gt;  <span class="kw">in</span>  out <span class="dv">0</span> s</code></pre>
<p>and play it:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; play_s02_c <span class="fu">=</span> audition <span class="fu">$</span> mks02 lfCub<br />&gt; play_s02_t <span class="fu">=</span> audition <span class="fu">$</span> mks02 lfTri<br />&gt; play_s02_s <span class="fu">=</span> audition <span class="fu">$</span> mks02 lfSaw</code></pre>
<p>We can do similar thing without passing function as an argument. <code>UGen</code> functions <code>sinOsc</code>, <code>lfCub</code>, <code>lfPar</code>, <code>lfSaw</code>, <code>lfTri</code> are defined with <code>Primitive</code> constructor:</p>
<pre><code>| *AdhocUpdate&gt; sinOsc AR 440 0
| Primitive { ugenRate = AR
|           , ugenName = &quot;SinOsc&quot;
|           , ugenInputs = [Constant {constantValue = 4400.0}
|                          ,Constant {constantValue = 0.0}]
|           , ugenOutputs = [AR], ugenSpecial = Special 0, ugenId = -1}
</code></pre>
<p>A function to update <code>Primitive</code>:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">primu </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span><br />&gt; primu from to ug <span class="fu">=</span> transform f ug <span class="kw">where</span><br />&gt;   f p<span class="fu">@</span>(<span class="dt">Primitive</span> r n is os s idx) <span class="fu">|</span> n <span class="fu">==</span> from <span class="fu">=</span> p {ugenName <span class="fu">=</span> to}<br />&gt;   f x <span class="fu">=</span> x</code></pre>
<p>Using <code>primu</code>, we can update <code>sinOsc</code> used in <code>s01</code> to different oscillator.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">set_osc_s01 </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span><br />&gt; set_osc_s01 <span class="fu">=</span> <span class="fu">flip</span> (primu <span class="st">&quot;SinOsc&quot;</span>) s01<br />&gt; <br />&gt; play_s01_cub, play_s01_tri,<span class="ot"> play_s01_saw </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; play_s01_cub <span class="fu">=</span> audition <span class="fu">$</span> set_osc_s01 <span class="st">&quot;LFCub&quot;</span><br />&gt; play_s01_tri <span class="fu">=</span> audition <span class="fu">$</span> set_osc_s01 <span class="st">&quot;LFTri&quot;</span><br />&gt; play_s01_saw <span class="fu">=</span> audition <span class="fu">$</span> set_osc_s01 <span class="st">&quot;LFSaw&quot;</span></code></pre>
<p>By using <code>String</code> to specify <code>UGen</code> name, we loosed type safety. We can have chance to send a <code>UGen</code> graph that does not work.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; s01_ng1 <span class="fu">=</span> set_osc_s01 <span class="st">&quot;NoSuchUnitGenerator&quot;</span></code></pre>
<p>Invoking <code>audition s01_ng1</code> will show an error message in scsynth:</p>
<pre><code>exception in GraphDef_Recv: UGen 'NoSuchUnitGenerator' not installed.
</code></pre>
<p>Thereâ€™s another chance to send malformed UGen graph, to update a ugen with different inputs. <code>UGen</code> function <code>phasor</code> has type:</p>
<pre><code>| phasor :: Rate -&gt; UGen -&gt; UGen -&gt; UGen -&gt; UGen -&gt; UGen -&gt; UGen
</code></pre>
<p>Its type is different from <code>sinOsc</code>:</p>
<pre><code>| sinOsc :: Rate -&gt; UGen -&gt; UGen -&gt; UGen
</code></pre>
<p>Though, we can update <code>&quot;SinOsc&quot;</code> with <code>&quot;Phasor&quot;</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; s01_ng2 <span class="fu">=</span> primu <span class="st">&quot;SinOsc&quot;</span> <span class="st">&quot;Phasor&quot;</span> s01</code></pre>
<p>Again, this likely to give us unintended result. Is there any safer way to do this?</p>
<p>We can pass oscillator function instead of <code>String</code> to get the name of <code>UGen</code>. <code>&quot;LFCub&quot;</code> string literal used in above <code>play_s01_cub</code> was picked up from this result:</p>
<pre><code>| *AdhocUpdate&gt; lfCub AR 440 0
</code></pre>
<p>Let us call this type as <code>OscUG</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="kw">type</span> <span class="dt">OscUG</span> <span class="fu">=</span> <span class="dt">Rate</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span></code></pre>
<p>Rewrite <code>set_osc_s01</code> to:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">set_osc_s01' </span><span class="ot">::</span> <span class="dt">OscUG</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span><br />&gt; set_osc_s01' o <span class="fu">=</span> primu <span class="st">&quot;SinOsc&quot;</span> (oscName o) s01<br />&gt; <br />&gt; <span class="ot">oscName </span><span class="ot">::</span> <span class="dt">OscUG</span> <span class="ot">-&gt;</span> <span class="dt">String</span><br />&gt; oscName o <span class="fu">=</span> ugenName (o <span class="dt">AR</span> <span class="dv">0</span> <span class="dv">0</span>)</code></pre>
<p>Note the use of dummy arguments <code>AR</code>, <code>0</code>, and <code>0</code>. Using <code>oscName</code>, <code>OscUG</code> could be shown as <code>String</code>. Make it an instance of <code>Show</code> class.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="kw">instance</span> <span class="kw">Show</span> <span class="dt">OscUG</span> <span class="kw">where</span><br />&gt;   <span class="fu">show</span> <span class="fu">=</span> oscName</code></pre>
<p>We can write a function to swap all occurance of <code>OscUG</code> s.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">swapOsc </span><span class="ot">::</span> <span class="dt">OscUG</span> <span class="ot">-&gt;</span> <span class="dt">OscUG</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span><br />&gt; swapOsc from to ug <span class="fu">=</span> primu (oscName from) (oscName to) ug</code></pre>
<p>Below will swap all <code>sinOsc</code> to <code>lfSaw</code> in <code>s01</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">play_s01_saw' </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; play_s01_saw'<span class="fu">=</span> audition <span class="fu">$</span> swapOsc sinOsc lfSaw s01</code></pre>
<p>Example usage of <code>swapOsc</code>, randomly replacing <code>sinOsc</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">oscUGs </span><span class="ot">::</span> [<span class="dt">OscUG</span>]<br />&gt; oscUGs <span class="fu">=</span> [sinOsc,fSinOsc,lfPar,lfCub,lfTri,lfSaw]<br />&gt; <br />&gt; <span class="ot">randomOscUG </span><span class="ot">::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> g <span class="ot">-&gt;</span> (<span class="dt">OscUG</span>, g)<br />&gt; randomOscUG g <span class="fu">=</span> <span class="kw">case</span> randomR (<span class="dv">0</span>, <span class="fu">length</span> oscUGs <span class="fu">-</span> <span class="dv">1</span>) g <span class="kw">of</span><br />&gt;     (i,g') <span class="ot">-&gt;</span> (oscUGs <span class="fu">!!</span> i, g')</code></pre>
<p><code>randomOscUG</code> will randomly return oscillators:</p>
<pre><code>| *AdhocUpdate&gt; replicateM 5 (getStdRandom randomOscUG)
| [LFPar,FSinOsc,LFSaw,FSinOsc,LFPar]
</code></pre>
<p>Make a synth containing 30 sinOscs.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">s03 </span><span class="ot">::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">UGen</span><br />&gt; s03 ff <span class="fu">=</span><br />&gt;   <span class="kw">let</span> mko f a d <span class="fu">=</span> sinOsc <span class="dt">AR</span> (mkf f) <span class="dv">0</span> <span class="fu">*</span> (mke a d) <span class="fu">*</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">01</span><br />&gt;       mkf f <span class="fu">=</span> constant f<br />&gt;       mke a d <span class="fu">=</span> envGen <span class="dt">KR</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dt">DoNothing</span> <span class="fu">$</span> envSine a d<br />&gt;       me <span class="fu">=</span> envGen <span class="dt">KR</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dt">RemoveSynth</span> <span class="fu">$</span> envLinen <span class="dv">0</span> <span class="dv">5</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">5</span> <span class="dv">1</span><br />&gt;       os <span class="fu">=</span> <span class="fu">zipWith3</span> mko<br />&gt;            [x<span class="fu">*</span><span class="dv">1</span><span class="fu">.</span><span class="dv">2081</span> <span class="fu">|</span> x <span class="ot">&lt;-</span> [ff,ff<span class="fu">*</span><span class="dv">2</span><span class="fu">..</span>]]<br />&gt;            [<span class="dv">1</span><span class="fu">.</span><span class="dv">25</span><span class="fu">**</span>x  <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span><span class="fu">..</span>]]<br />&gt;            [<span class="dv">2</span><span class="fu">.</span><span class="dv">5</span><span class="fu">*</span>x    <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">10</span>,<span class="dv">9</span><span class="fu">..</span>]]<br />&gt;       sig <span class="fu">=</span> (mix <span class="fu">$</span> mce <span class="fu">$</span> <span class="fu">take</span> <span class="dv">30</span> os) <span class="fu">*</span> me<br />&gt;   <span class="kw">in</span>  out <span class="dv">0</span> (pan2 sig <span class="dv">0</span> <span class="dv">1</span>)</code></pre>
<p>And a function to randomly replace <code>sinOsc</code> with <code>getStdRandom</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">randomizeOsc </span><span class="ot">::</span> <span class="dt">UGen</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">UGen</span><br />&gt; randomizeOsc ug <span class="fu">=</span> transformM k ug <span class="kw">where</span><br />&gt;   k (<span class="dt">Primitive</span> r n is os s j)<br />&gt;     <span class="fu">|</span> n <span class="fu">==</span> <span class="st">&quot;SinOsc&quot;</span> <span class="fu">=</span> getStdRandom randomOscUG <span class="fu">&gt;&gt;=</span> \o <span class="ot">-&gt;</span><br />&gt;       <span class="fu">return</span> <span class="fu">$</span> <span class="dt">Primitive</span> r (oscName o) is os s j<br />&gt;   k x <span class="fu">=</span> <span class="fu">return</span> x</code></pre>
<p>Takes fundamental frequency and play sum of oscillators. Oscillators used for each partial are choosed randomly.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">play_s03_rand </span><span class="ot">::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()<br />&gt; play_s03_rand x <span class="fu">=</span> audition <span class="fu">=&lt;&lt;</span> randomizeOsc (s03 x)</code></pre>
<p>Invoking:</p>
<pre><code>| *AdhocUpdate&gt; play_s03_rand 30
</code></pre>
<p>will build a UGen graph with randomly chosen oscillator UGen for each partial.</p>
<p>Variation without using generic update. Type signature of this synth is <code>IO UGen</code>, since its callling <code>randomOscUG</code> inside.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">s03' </span><span class="ot">::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">UGen</span><br />&gt; s03' ff <span class="fu">=</span> <span class="kw">do</span><br />&gt;   ougs <span class="ot">&lt;-</span> replicateM <span class="dv">30</span> (getStdRandom randomOscUG)<br />&gt;   <span class="kw">let</span> mko o f a d <span class="fu">=</span> o <span class="dt">AR</span> (mkf f) <span class="dv">0</span> <span class="fu">*</span> (mke a d) <span class="fu">*</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">01</span><br />&gt;       mkf f <span class="fu">=</span> constant f<br />&gt;       mke a d <span class="fu">=</span> envGen <span class="dt">KR</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dt">DoNothing</span> <span class="fu">$</span> envSine a d<br />&gt;       me <span class="fu">=</span> envGen <span class="dt">KR</span> <span class="dv">1</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dt">RemoveSynth</span> <span class="fu">$</span> envLinen <span class="dv">0</span> <span class="dv">5</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">5</span> <span class="dv">1</span><br />&gt;       os <span class="fu">=</span> zipWith4 mko<br />&gt;            ougs<br />&gt;            [x<span class="fu">*</span><span class="dv">1</span><span class="fu">.</span><span class="dv">2081</span> <span class="fu">|</span> x <span class="ot">&lt;-</span> [ff,ff<span class="fu">*</span><span class="dv">2</span><span class="fu">..</span>]]<br />&gt;            [<span class="dv">1</span><span class="fu">.</span><span class="dv">25</span><span class="fu">**</span>x  <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span><span class="fu">..</span>]]<br />&gt;            [<span class="dv">2</span><span class="fu">.</span><span class="dv">5</span><span class="fu">*</span>x    <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">10</span>,<span class="dv">9</span><span class="fu">..</span>]]<br />&gt;       sig <span class="fu">=</span> (mix <span class="fu">$</span> mce os) <span class="fu">*</span> me<br />&gt;   <span class="fu">return</span> <span class="fu">$</span> out <span class="dv">0</span> (pan2 sig <span class="dv">0</span> <span class="dv">1</span>)</code></pre>
<p>The result UGen graph is different from <code>s03</code>. Since <code>s03</code> may replaces oscillator used for left and right of same frequency with different oscillators. s03â€™ uses same oscillator for left and right of same frequency.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">play_s03_rand' </span><span class="ot">::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()<br />&gt; play_s03_rand' x <span class="fu">=</span> audition <span class="fu">=&lt;&lt;</span> s03' x</code></pre>
</div>

<div class="post_tags">
  <strong>Tags: </strong><a href="../tags/haskell.html">haskell</a>, <a href="../tags/supercollider.html">supercollider</a>, <a href="../tags/generic.html">generic</a>
</div>


      </div>
      <div id="footer">
        <div id="footer_content">
          <p>
            <a href="../index.html">Home</a> |
            <a href="../archive.html">Archive</a> |
            <a href="../rss.xml">RSS</a>
          </p>

          Site contents licensed under
          <a href="http://creativecommons.org/licenses/by/3.0/">
            CC Attribution 3.0
          </a>
        </div>
      </div>
    </div>
  </body>
</html>

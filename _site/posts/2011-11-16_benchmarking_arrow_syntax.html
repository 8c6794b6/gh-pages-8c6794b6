<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Warm Fuzzy Thing - Benchmarking arrow syntax</title>
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/ico">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/hk-tango.css">
    <link rel="alternate" type="application/rss+xml" title="Warm Fuzzy Thing" href="../rss.xml">
  </head>
  <body>
    <div>
      <div id="site_name">
        <div id="site_name_contents">
          <a href="../index.html">Warm Fuzzy Thing</a>
        </div>
      </div>

      <div id="header">
        <div id="header_contents">
          <div id="navigation">
            <a href="../index.html">Home</a>
            <a href="../archive.html">Archive</a>
            <a href="../rss.xml">RSS</a>
          </div>
        </div>
      </div>

      <div id="content">

        <h1>Benchmarking arrow syntax</h1>
<div id="post_date">
  <strong>November 16, 2011</strong>
</div>

<div id="post_body">
<p>Recently I read a paper about <a href="http://cs.yale.edu/c2/images/uploads/AudioProc-TR.pdf">“Audio Processing and Sound Synthesis in Haskell”</a> which uses <code>Arrow</code> and <code>[Double]</code> for its building block of signal data. While reading the document, it shows that using Arrow syntax will make the code slow, due to its wrapping and unwrapping in desugared tuples.</p>
<p>Does arrow syntax make the code slow?</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">{-# LANGUAGE Arrows, BangPatterns, NoImplicitPrelude #-}</span><br />&gt; <span class="kw">module</span> <span class="dt">BenchArrowSyntax</span> <span class="kw">where</span><br />&gt; <span class="kw">import</span> <span class="dt">Control.Arrow</span><br />&gt; <span class="kw">import</span> <span class="dt">Control.Category</span><br />&gt; <span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((<span class="fu">.</span>), <span class="fu">id</span>)<br />&gt; <br />&gt; <span class="kw">import</span> <span class="dt">Control.DeepSeq</span><br />&gt; <span class="kw">import</span> <span class="dt">Criterion.Main</span></code></pre>
<p>Comparing performance of code written in below styles:</p>
<ol style="list-style-type: decimal">
<li>Pure function, no Arrows (<em>plain</em>).</li>
<li>Arrows, without syntax sugar (<em>bitter</em>).</li>
<li>Arrows, with syntax sugar (<em>sweet</em>).</li>
<li>Arrows, with syntax sugar, inlined (<em>sweet-inline</em>).</li>
</ol>
<p>The GHC version used to benchmark this code was 7.0.3. The main function looks like this:</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">main </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />&gt; main <span class="fu">=</span><br />&gt;  <span class="kw">let</span> <span class="fu">!</span>xs <span class="fu">=</span> <span class="kw">let</span> ys <span class="fu">=</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10000</span>] <span class="kw">in</span> ys <span class="ot">`deepseq`</span> ys<br />&gt;  <span class="kw">in</span>  defaultMain<br />&gt;        [ bench <span class="st">&quot;plain&quot;</span> (whnf (<span class="fu">map</span> plain) xs)<br />&gt;        , bench <span class="st">&quot;bitter&quot;</span> (whnf (unA bitter) xs)<br />&gt;        , bench <span class="st">&quot;sweet&quot;</span> (whnf (unA sweet) xs)<br />&gt;        , bench <span class="st">&quot;sweet-inline&quot;</span> (whnf (unB sweet_inline) xs)<br />&gt;        ]</code></pre>
<p>Showing the result of running the compiled code:</p>
<pre><code>$ ghc --make -O2 -o a.out -main-is BenchArrowSyntax BenchArrowSyntax.lhs
[1 of 1] Compiling BenchArrowSyntax ( bench_arrow_syntax.lhs, bench_arrow_syntax.o )
Linking a.out ...
$ ./a.out
warming up
estimating clock resolution...
mean is 16.06060 us (40001 iterations)
found 2976 outliers among 39999 samples (7.4%)
  1930 (4.8%) high mild
  1041 (2.6%) high severe
estimating cost of a clock call...
mean is 103.2901 ns (61 iterations)

benchmarking plain
mean: 29.50057 ns, lb 29.43500 ns, ub 29.60982 ns, ci 0.950
std dev: 422.9860 ps, lb 275.5593 ps, ub 700.1025 ps, ci 0.950

benchmarking bitter
mean: 29.60260 ns, lb 29.57317 ns, ub 29.63793 ns, ci 0.950
std dev: 164.7924 ps, lb 139.0684 ps, ub 196.2178 ps, ci 0.950

benchmarking sweet
mean: 261.4728 ns, lb 261.1549 ns, ub 261.9058 ns, ci 0.950
std dev: 1.876539 ns, lb 1.454937 ns, ub 3.033409 ns, ci 0.950

benchmarking sweet-inline
mean: 135.2866 ns, lb 134.9794 ns, ub 135.5847 ns, ci 0.950
std dev: 1.552157 ns, lb 1.412139 ns, ub 1.726597 ns, ci 0.950
</code></pre>
<p>It shows that the code written with arrow syntax runs about 9 times slower than the others, and there’s not so much difference between plain function from arrow codes written without syntax sugar. What’s going on with arrow syntax?</p>
<p>Below 2 functions were used in this benchmark. Simple addition and multiplication for <code>Int</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">func1 </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><br />&gt; func1 <span class="fu">=</span> (<span class="fu">+</span><span class="dv">3</span>)<br />&gt; <br />&gt; <span class="ot">func2 </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><br />&gt; func2 <span class="fu">=</span> (<span class="fu">*</span><span class="dv">7</span>)</code></pre>
<p>The type to implement <code>Arrow</code> instance for <code>bitter</code> and <code>sweet</code>. It is a simple newtype wrapper for mapping function over list.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="kw">newtype</span> <span class="dt">A</span> a b <span class="fu">=</span> <span class="dt">A</span> {<span class="ot">unA </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> [b]}<br />&gt; <br />&gt; <span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">A</span> <span class="kw">where</span><br />&gt;   <span class="fu">id</span> <span class="fu">=</span> <span class="dt">A</span> <span class="fu">id</span><br />&gt;   <span class="dt">A</span> f <span class="fu">.</span> <span class="dt">A</span> g <span class="fu">=</span> <span class="dt">A</span> (f <span class="fu">.</span> g)<br />&gt; <br />&gt; <span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">A</span> <span class="kw">where</span><br />&gt;   arr f <span class="fu">=</span> <span class="dt">A</span> (<span class="fu">map</span> f)<br />&gt;   first (<span class="dt">A</span> f) <span class="fu">=</span> <span class="dt">A</span> <span class="fu">$</span> <span class="fu">uncurry</span> <span class="fu">zip</span> <span class="fu">.</span> first f <span class="fu">.</span> <span class="fu">unzip</span></code></pre>
<p>First, the plain function. In other word, a function with <code>(-&gt;)</code> type.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">plain </span><span class="ot">::</span> (<span class="ot">-&gt;</span>) <span class="dt">Int</span> <span class="dt">Int</span><br />&gt; plain <span class="fu">=</span> func2 <span class="fu">.</span> func1</code></pre>
<p>Dumped core of <code>plain</code>, removed couple type signatures and variable suffixes for clarity.</p>
<pre><code>| plain :: Int -&gt; Int
| plain = \(x :: Int) -&gt; case x of _ { I# x1 -&gt; I# (*# (+# x1 3) 7) }
</code></pre>
<p>Next, arrow without syntax. Manually wrapping functions with <code>arr</code>, and combining with <code>(&gt;&gt;&gt;)</code> operator.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">bitter </span><span class="ot">::</span> <span class="dt">A</span> <span class="dt">Int</span> <span class="dt">Int</span><br />&gt; bitter <span class="fu">=</span> arr func1 <span class="fu">&gt;&gt;&gt;</span> arr func2</code></pre>
<p>Excerpt of dumped core of <code>bitter</code>. Again, GHC type prefix and variable suffixes are removed.</p>
<pre><code>| bitter :: A Int Int
| bitter =
|   bitter1
|   `cast` (sym (A Int Int)
|           :: ([Int] -&gt; [Int]) ~ BenchArrowSyntax.A Int Int)
|
| bitter1 :: [Int] -&gt; [Int]
| bitter1 = \(x :: [Int]) -&gt; map bitter2 x
|
| bitter2 :: Int -&gt; Int
| bitter2 = \(x :: Int) -&gt; case x of _ { I# x1 -&gt; I# (*# (+# x1 3) 7) }
</code></pre>
<p>Though delegation from <code>bitter</code> to <code>bitter1</code> and <code>bitter2</code> exists, from what we see in the function body of <code>bitter2</code>, the guts of its definition remains same as <code>plain</code>.</p>
<p>And then, with arrow syntax. In its body, result of each arrow are bounded to varialbe with explicit name. Requires <code>Arrows</code> LANGUAGE pragma.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">sweet </span><span class="ot">::</span> <span class="dt">A</span> <span class="dt">Int</span> <span class="dt">Int</span><br />&gt; sweet <span class="fu">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span><br />&gt;   y <span class="ot">&lt;-</span> arr func1 <span class="fu">-&lt;</span> x<br />&gt;   z <span class="ot">&lt;-</span> arr func2 <span class="fu">-&lt;</span> y<br />&gt;   returnA <span class="fu">-&lt;</span> z</code></pre>
<p>Excerpt dumped core of <code>sweet</code>. We see zipping and unzipping done during the desugaring of syntax, in <code>main12</code> and <code>$fArrowA3</code>.</p>
<pre><code>| sweet :: A Int Int
| sweet =
|   main12 `cast` (sym (NTCo:A Int Int) :: ([Int] -&gt; [Int]) ~ A Int Int)
|
| main12 :: [Int] -&gt; [Int]
| main12 =
|   \(x :: [Int]) -&gt;
|    case $fArrowA3 (map main17 x) of _
|      { (# ww1, ww2 #) -&gt;
|        case $fArrowA3 (map main16 (zip (map main15 ww1) ww2)) of _
|           { (# ww4, ww5 #) -&gt; map main14 (zip (map main13 ww4) ww5)
|      }
|    }
|
| main17 :: Int -&gt; (Int, ())
| main17 = \(x :: Int) -&gt; (x, ())
|
| main16 :: (Int, ()) -&gt; (Int, ())
| main16 =
|   \(x :: (Int, ())) -&gt;
|    (case x of _ { (y, ds1) -&gt; case ds1 of _ { () -&gt; y } }, ())
|
| main15 :: Int -&gt; Int
| main15 = \(x :: Int) -&gt; case x of _ { I# x1 -&gt; I# (+# x1 3) }
|
| main14 :: (Int, ()) -&gt; Int
| main14 =
|   \(x :: (Int, ())) -&gt;
|    case x of _ { (z2, ds1) -&gt;
|      case ds1 of _ { () -&gt; z2 }
|    }
|
| main13 :: Int -&gt; Int
| main13 = \ (x :: Int) -&gt; case x of _ { I# x1 -&gt; I# (*# x1 7) }
|
| Rec {
| $fArrowA3 :: forall b d. [(b, d)] -&gt; (# [b], [d] #)
| $fArrowA3 =
|   \(w :: [(b, d)]) -&gt;
|    case w of _ {
|      [] -&gt; (# [], [] #);
|      : y ys -&gt;
|        case y of _ { (a1, b) -&gt;
|        let {
|          ds1 :: ([b], [d])
|          ds1 =
|            case $fArrowA3 ys of _ { (# ww1, ww2 #) -&gt; (ww1, ww2) } } in
|        (# : a1 (case ds1 of _ { (as, bs) -&gt; as }),
|           : b (case ds1 of _ { (as, bs) -&gt; bs }) #)
|        }
|    }
| end Rec }
</code></pre>
<p>Finally, Arrow syntax with INLINE pragma. The only difference between newtype <code>A</code> and <code>B</code> is, the use of <code>INLINE</code> in function <code>first</code>. The function body of <code>sweet</code> and <code>sweet_inline</code>, and definitions for <code>Arrow</code> class in A and B are identical.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="kw">newtype</span> <span class="dt">B</span> a b <span class="fu">=</span> <span class="dt">B</span> {<span class="ot">unB </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> [b]}<br />&gt; <br />&gt; <span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">B</span> <span class="kw">where</span><br />&gt;   <span class="fu">id</span> <span class="fu">=</span> <span class="dt">B</span> <span class="fu">id</span><br />&gt;   <span class="dt">B</span> f <span class="fu">.</span> <span class="dt">B</span> g <span class="fu">=</span> <span class="dt">B</span> (f <span class="fu">.</span> g)<br />&gt; <br />&gt; <span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">B</span> <span class="kw">where</span><br />&gt;   arr f <span class="fu">=</span> <span class="dt">B</span> (<span class="fu">map</span> f)<br />&gt;   <span class="ot">{-# INLINE first #-}</span><br />&gt;   first (<span class="dt">B</span> f) <span class="fu">=</span> <span class="dt">B</span> <span class="fu">$</span> <span class="fu">uncurry</span> <span class="fu">zip</span> <span class="fu">.</span> first f <span class="fu">.</span> <span class="fu">unzip</span><br />&gt; <br />&gt; <span class="ot">sweet_inline </span><span class="ot">::</span> <span class="dt">B</span> <span class="dt">Int</span> <span class="dt">Int</span><br />&gt; sweet_inline <span class="fu">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span><br />&gt;   y <span class="ot">&lt;-</span> arr func1 <span class="fu">-&lt;</span> x<br />&gt;   z <span class="ot">&lt;-</span> arr func2 <span class="fu">-&lt;</span> y<br />&gt;   returnA <span class="fu">-&lt;</span> z</code></pre>
<p>Excerpt dumped core of <code>sweet_inline</code>. Note that <code>zip</code> function is not used. Instead, more <code>Rec</code> blocks are used. <code>sweet_inline</code> runs 2x faster than <code>sweet</code>, a big difference made from single <code>INLINE</code> pragma.</p>
<pre><code>| sweet_inline :: B Int Int
| sweet_inline =
|   main8 `cast` (sym (NTCo:B Int Int) :: ([Int] -&gt; [Int]) ~ B Int Int)
|
| main8 :: [Int] -&gt; [Int]
| main8 =
|   \(x :: [Int]) -&gt;
|    case $wgo x of _ { (# ww1, ww2 #) -&gt;
|      case main_go1 ww1 ww2 of _ { (x1, y) -&gt;
|        main_go x1 y
|      }
|    }
|
| Rec {
| $wgo :: [Int] -&gt; (# [Int], [()] #)
| $wgo =
|   \(w :: [Int]) -&gt;
|    case w of _ {
|      [] -&gt; (# [] @ Int, [] @ () #);
|      : y ys -&gt;
|        let {
|          ys1 :: ([Int], [()])
|          ys1 =
|            case $wgo ys
|            of _ { (# ww1, ww2 #) -&gt;
|            (ww1, ww2)
|            } } in
|        (# : y (case ys1 of _ { (as, bs) -&gt; as }),
|           : () (case ys1 of _ { (as, bs) -&gt; bs }) #)
|    }
| end Rec }
|
| Rec {
| main_go1 :: [Int] -&gt; [()] -&gt; ([Int], [()])
| main_go1 =
|   \(ds :: [Int]) -&gt;
|    case ds of _ {
|      [] -&gt; z;
|      : y ys -&gt;
|        let {
|          _x :: Int
|          _x = y of _ { I# x -&gt; I# (+# x 3) } } in
|        let {
|          ys1 :: [()] -&gt; ([Int], [()])
|          ys1 = main_go1 ys } in
|        \ (ds1 :: [()]) -&gt;
|          case ds1 of _ {
|            [] -&gt; n_r2wU;
|            : y1 ys2 -&gt;
|              let {
|                ys3 :: ([Int], [()])
|                ys3 = ys1 ys2 } in
|              (: (case y1 of _ { () -&gt; _x })
|                 (case ys3 of _ { (as, bs) -&gt; as }),
|               : ()
|                 (case ys3 of _ { (as, bs) -&gt; bs }))
|          }
|    }
| end Rec }
|
| n_r2wU :: ([Int], [()])
| n_r2wU = ([], [])
|
| Rec {
| main_go :: [Int] -&gt; [()] -&gt; [Int]
| main_go =
|   \(ds :: [Int]) -&gt;
|    case ds of _ {
|      [] -&gt; z1;
|      : y ys -&gt;
|        let {
|          _x :: Int
|          _x = case y of _ { I# x -&gt; I# (*# x 7) } } in
|        let {
|          ys1 :: [()] -&gt; [Int]
|          ys1 = main_go ys } in
|        \ (ds1 :: [()]) -&gt;
|          case ds1 of _ {
|            [] -&gt; [];
|            : y1 ys2 -&gt;
|              : (case y1 of _ { () -&gt; _x })
|                (ys1 ys2)
|          }
|    }
| end Rec }
</code></pre>
<p>So, indeed, arrow syntax made the code slow, as written in the paper, mainly due to those use of tupling and untupling to reference varialbes by names, as we can find in <code>sweet</code> and <code>sweet_inline</code>. When arrow is used without syntax sugar, and there’s no tuple packing nor unpacking, its performance is almost same as pure function variant, as we see in comparison of <code>plain</code> and <code>bitter</code>.</p>
<p>When do want to use arrow syntax, even we know that it runs slower? The main cause of slow down was packing and unpacking of tuples. When we see that these use of tupes are inevitable, it may show a better looking code. I have not yet met a practical situation heavily using arrow syntax, which seems valueable enough for performance trade-off.</p>
</div>

<div class="post_tags">
  <strong>Tags: </strong><a href="../tags/haskell.html">haskell</a>, <a href="../tags/arrow.html">arrow</a>, <a href="../tags/performance.html">performance</a>
</div>


      </div>
      <div id="footer">
        <div id="footer_content">
          <p>
            <a href="../index.html">Home</a> |
            <a href="../archive.html">Archive</a> |
            <a href="../rss.xml">RSS</a>
          </p>

          Site contents licensed under
          <a href="http://creativecommons.org/licenses/by/3.0/">
            CC Attribution 3.0
          </a>
        </div>
      </div>
    </div>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Warm Fuzzy Thing - Extracting argument names</title>
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/ico">
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link rel="stylesheet" type="text/css" href="../css/hk-tango.css">
    <link rel="alternate" type="application/rss+xml" title="Warm Fuzzy Thing" href="../rss.xml">
  </head>
  <body>
    <div>
      <div id="site_name">
        <div id="site_name_contents">
          <a href="../index.html">Warm Fuzzy Thing</a>
        </div>
      </div>

      <div id="header">
        <div id="header_contents">
          <div id="navigation">
            <a href="../index.html">Home</a>
            <a href="../archive.html">Archive</a>
            <a href="../rss.xml">RSS</a>
          </div>
        </div>
      </div>

      <div id="content">

        <h1>Extracting argument names</h1>
<div id="post_date">
  <strong>December 10, 2011</strong>
</div>

<div id="post_body">
<p>Can we extract argument names from haskell function?</p>
<p>What <em>extracting the argument names</em> means, when we had a function <code>foo</code>:</p>
<pre><code>| foo :: Int -&gt; Int -&gt; Int -&gt; String
| foo apple banana cherry = show (apple*60 + banana*30 + cherry*10)
</code></pre>
<p>We want to get the bounded variables: ‘apple’, ‘banana’, and ‘cherry’. It is possible to write this argument extracter with template haskell, generics, and haskell source code representation.</p>
<p>We want to call the extracter function <code>funArgs</code> by writing something like below, in caller module:</p>
<pre><code>| fooargs :: [String]
| fooargs = $(funArgs 'foo)
</code></pre>
<p>Loading the module in ghci, and viewing the result:</p>
<pre><code>| ghci&gt; print fooargs
| [&quot;apple&quot;,&quot;banana&quot;,&quot;cherry&quot;]
</code></pre>
<p>We see variable names: <code>apple</code>, <code>banana</code>, and <code>cherry</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="kw">module</span> <span class="dt">FunArgs</span> (funArgs) <span class="kw">where</span><br />&gt; <br />&gt; <span class="kw">import</span> <span class="dt">Control.Monad</span> (when)<br />&gt; <span class="kw">import</span> <span class="dt">Data.Generics</span> (everything, mkQ)<br />&gt; <span class="kw">import</span> <span class="dt">Language.Haskell.TH</span> <span class="kw">hiding</span> (<span class="dt">Match</span>)<br />&gt; <span class="kw">import</span> <span class="dt">System.Directory</span> (doesFileExist)</code></pre>
<p>Using <code>haskell-src-exts</code> package. Alternatively, one can use <code>haskell-src</code> package, when working with haskell98 source codes only. Importing with hiding <code>Name</code> and <code>listE</code>, since it conflicts with <code>Language.Haskell.TH</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="kw">import</span> <span class="dt">Language.Haskell.Exts</span> <span class="kw">hiding</span> (<span class="dt">Name</span>, listE)</code></pre>
<p>The worker function will take a <code>Name</code> of target function to extract variable names, and returns TH expression.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">funArgs </span><span class="ot">::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">ExpQ</span></code></pre>
<p>Firstly, accessing the source code of caller. In current implementation, <code>funArgs</code> cannot extract a function defined in ghci interactively. In this case, merely calling <code>error</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; funArgs fname <span class="fu">=</span> <span class="kw">do</span><br />&gt;   path <span class="ot">&lt;-</span> loc_filename <span class="ot">`fmap`</span> location<br />&gt;   exists <span class="ot">&lt;-</span> runIO <span class="fu">$</span> doesFileExist path<br />&gt;   when (<span class="fu">not</span> exists) <span class="fu">$</span> <span class="fu">error</span> <span class="fu">$</span> <span class="st">&quot;Cannot access: &quot;</span> <span class="fu">++</span> path<br />&gt;   result <span class="ot">&lt;-</span> runIO <span class="fu">$</span> parseFileWithMode defaultParseMode path<br />&gt;   <span class="kw">case</span> result <span class="kw">of</span><br />&gt;     <span class="dt">ParseFailed</span> l e <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="fu">$</span> <span class="st">&quot;Failed to parse: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> l <span class="fu">++</span> <span class="st">&quot;, &quot;</span> <span class="fu">++</span> e<br />&gt;     <span class="dt">ParseOk</span> mdl     <span class="ot">-&gt;</span> extractArgs mdl fname</code></pre>
<p>When we can acces the source code, parsing the source code to get haskell representation. Parsing may fail, and in that case, showing error message with <code>error</code> again. There should be nicer way to handle these error cases, though we just print out the messages, and moving on for now.</p>
<p>Guts of argument extracter is shown below. Applying pattern match and collecting matches with <code>everything</code> and <code>mkQ</code>. When we find the target function, extracting the contents of <code>Ident</code>.</p>
<pre class="sourceCode"><code class="sourceCode haskell">&gt; <span class="ot">extractArgs </span><span class="ot">::</span> <span class="dt">Module</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">ExpQ</span><br />&gt; extractArgs mdl fname <span class="fu">=</span> <span class="kw">do</span><br />&gt;    <span class="kw">let</span> args <span class="fu">=</span> everything (<span class="fu">++</span>) ([] <span class="ot">`mkQ`</span> arg) mdl<br />&gt;        arg m <span class="fu">=</span> <span class="kw">case</span> m <span class="kw">of</span><br />&gt;          <span class="dt">Match</span> _ (<span class="dt">Ident</span> idnt) ps _ _ _<br />&gt;            <span class="fu">|</span> idnt <span class="fu">==</span> name' <span class="ot">-&gt;</span> <span class="fu">map</span> unPVar ps<br />&gt;            <span class="fu">|</span> <span class="fu">otherwise</span>     <span class="ot">-&gt;</span> []<br />&gt;          _ <span class="ot">-&gt;</span> []<br />&gt;        name' <span class="fu">=</span> nameBase fname<br />&gt;        unPVar pv <span class="fu">=</span> <span class="kw">case</span> pv <span class="kw">of</span><br />&gt;          <span class="dt">PVar</span> n <span class="ot">-&gt;</span> <span class="kw">case</span> n <span class="kw">of</span> <span class="dt">Ident</span> i <span class="ot">-&gt;</span> i; _ <span class="ot">-&gt;</span> <span class="st">&quot;&quot;</span><br />&gt;          _      <span class="ot">-&gt;</span> <span class="st">&quot;&quot;</span><br />&gt;    listE (<span class="fu">map</span> (litE <span class="fu">.</span> stringL) args)</code></pre>
<p>By the way, this argument extracter was heavily inspired by <a href="http://hackage.haskell.org/package/language-haskell-extract">language-haskell-extract</a>.</p>
</div>

<div class="post_tags">
  <strong>Tags: </strong><a href="../tags/haskell.html">haskell</a>, <a href="../tags/templatehaskell.html">templatehaskell</a>
</div>


      </div>
      <div id="footer">
        <div id="footer_content">
          <p>
            <a href="../index.html">Home</a> |
            <a href="../archive.html">Archive</a> |
            <a href="../rss.xml">RSS</a>
          </p>

          Site contents licensed under
          <a href="http://creativecommons.org/licenses/by/3.0/">
            CC Attribution 3.0
          </a>
        </div>
      </div>
    </div>
  </body>
</html>
